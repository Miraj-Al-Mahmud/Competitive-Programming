Total number of snippets >>> 87
************************************************************************
1th Snippet -> Name a2n 
a2n = {chr(k):v for k,v in zip(range(97,97+27),range(1,27))}

************************************************************************
2th Snippet -> Name binarySearch 
def binary_search_function(input_list:list, low_value:int, high_value:int,  target_value:int) -> None:
    if high_value >= low_value:
        middle = (high_value + low_value) // 2
        if input_list[middle] < target_value: return binary_search_function(input_list, middle +1, high_value, target_value)
        elif input_list[middle] > target_value: return binary_search_function(input_list, low_value, middle-1, target_value)
        else: return middle
    else: return [high_value,low_value]

************************************************************************
3th Snippet -> Name bitGenerator 
def bitGen( n : int ) -> list[int] : return [''.join(i) for i in itertools.product('01', repeat=n)]

************************************************************************
4th Snippet -> Name bitString 
n = int(input())
ans = 1
for _ in range(n): ans *= 2; ans %= 1e9+7
print(int(ans))

************************************************************************
5th Snippet -> Name bubbleSort 
def bubble_sort(arr):
    i = 0
    while i < len(arr):
        j = i + 1    
        while j < len(arr):
            if arr[j] < arr[i]: temp = arr[i]; arr[i] = arr[j]; arr[j] = temp
            j+=1
        i+=1
    return arr

************************************************************************
6th Snippet -> Name coinPiles 
'''Make A and B equal by removing 2 from A and 1 from B or vice versa'''
def coin_pile_2_1( a : int , b : int ) -> bool :
    if ((a + b) % 3 == 0 and 2 * a >= b and 2 * b >= a ): return True
    else: return False

************************************************************************
7th Snippet -> Name comment 
"""
${1:Your Comment Here}
"""

************************************************************************
8th Snippet -> Name currencyChange 
def currencyChange(change:int)->list:
    currency,n,ans,i = [1, 2, 5, 10, 20, 50, 100, 500, 1000],len(currency),[],n-1
    while i >= 0:
        while (change >= currency[i]): change -= currency[i]; ans.append(currency[i])
        i -= 1
    return ans

************************************************************************
9th Snippet -> Name cycle 
# listname, toBreakWhile, startingIndex, forward/reverse
def cycle(list_name : list, breakpoint, startIndex : int = 0, direction : int = 1) -> (int, list) :
    temp,tempStore = 0,[]
    for idx,i in enumerate(itertools.cycle(list_name[::direction])):
        if idx >= startIndex:
            if i!=breakpoint: temp+=1; tempStore.append(i)
            else: break
    return temp, tempStore

************************************************************************
10th Snippet -> Name debugAppend 
import baba_yaga; baba_yaga.debug('a',${1:data})

************************************************************************
11th Snippet -> Name debugWrite 
import baba_yaga; baba_yaga.debug('w',${1:data})

************************************************************************
12th Snippet -> Name diagonalDifference 
def diagonalDifference( arr : list ) -> int:
    mat = len(arr[0]) 
    left_sum = 0
    right_sum =0
    k =mat-1 
    for i in range(mat): left_sum += arr[i][i] 
    for j in range(mat):
        right_sum += arr[j][k]
        k-=1
    return abs(right_sum - left_sum)

************************************************************************
13th Snippet -> Name dictionary 
for item in ${1:arrayName}:
	${2:dick}.setdefault(item,0)
	${2:dick}[item]+=1 

************************************************************************
14th Snippet -> Name DublyLinkedList - Copy 
class DoublyLinkedList:
    def __init__(self):self.head = None
    def insertAtBeginning(self, new_data):
        new_node = Node(new_data)
        new_node.next = self.head
        if self.head is not None:
            self.head.prev = new_node
        self.head = new_node
    def insertAfter(self, prev_node, new_data):
        if prev_node is None:
            print("the given previous node cannot be NULL")
            return
        new_node = Node(new_data)
        new_node.next = prev_node.next
        prev_node.next = new_node
        new_node.prev = prev_node
        if new_node.next:
            new_node.next.prev = new_node
    def insertAtLast(self, new_data):
        new_node = Node(new_data)
        if self.head is None:
            self.head = new_node
            return
        last = self.head
        while last.next:
            last = last.next
        last.next = new_node
        new_node.prev = last
        return
    def printListForward(self):
        forward = []
        node = self.head
        while node:
            forward.append(node.data)
            last = node
            node = node.next
        return forward
    def printListBackward(self):
        backward = []
        while last:
            backward.append(last.data)
            last = last.prev
        return backward

************************************************************************
15th Snippet -> Name easeOverLapIntervals 
def eraseOverlapIntervals(intervals:list) -> int:
    end, cnt = float('-inf'), 0
    for s, e in sorted(intervals, key=lambda x: x[1]):
        if s >= end: end = e
        else: cnt += 1
    return cnt

************************************************************************
16th Snippet -> Name factorial 
def factorial(n,m = 1000000007):
    q = 1
    for i in range(n): q = (q * (i + 1)) % m
    return(q)

************************************************************************
17th Snippet -> Name factors 
def factors(n:int) -> list:
    q = []
    for i in range(1,int(n ** 0.5) + 1):
        if n % i == 0: q.append(i); q.append(n // i)
    return list(sorted(list(set(q))))

************************************************************************
18th Snippet -> Name fastIO 
from __future__ import division, print_function

import os
import sys
from io import BytesIO, IOBase

if sys.version_info[0] < 3:
    from __builtin__ import xrange as range
    from future_builtins import ascii, filter, hex, map, oct, zip
BUFSIZE = 8192


class FastIO(IOBase):
    newlines = 0

    def __init__(self, file):
        self._fd = file.fileno()
        self.buffer = BytesIO()
        self.writable = "x" in file.mode or "r" not in file.mode
        self.write = self.buffer.write if self.writable else None

    def read(self):
        while True:
            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))
            if not b:
                break
            ptr = self.buffer.tell()
            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)
        self.newlines = 0
        return self.buffer.read()

    def readline(self):
        while self.newlines == 0:
            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))
            self.newlines = b.count(b"\n") + (not b)
            ptr = self.buffer.tell()
            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)
        self.newlines -= 1
        return self.buffer.readline()

    def flush(self):
        if self.writable:
            os.write(self._fd, self.buffer.getvalue())
            self.buffer.truncate(0), self.buffer.seek(0)


class IOWrapper(IOBase):
    def __init__(self, file):
        self.buffer = FastIO(file)
        self.flush = self.buffer.flush
        self.writable = self.buffer.writable
        self.write = lambda s: self.buffer.write(s.encode("ascii"))
        self.read = lambda: self.buffer.read().decode("ascii")
        self.readline = lambda: self.buffer.readline().decode("ascii")


def print(*args, **kwargs):
    """Prints the values to a stream, or to sys.stdout by default."""
    sep, file = kwargs.pop("sep", " "), kwargs.pop("file", sys.stdout)
    at_start = True
    for x in args:
        if not at_start:
            file.write(sep)
        file.write(str(x))
        at_start = False
    file.write(kwargs.pop("end", "\n"))
    if kwargs.pop("flush", False):
        file.flush()


if sys.version_info[0] < 3:
    sys.stdin, sys.stdout = FastIO(sys.stdin), FastIO(sys.stdout)
else:
    sys.stdin, sys.stdout = IOWrapper(sys.stdin), IOWrapper(sys.stdout)

input = lambda: sys.stdin.readline().rstrip("\r\n")

************************************************************************
19th Snippet -> Name findMinimumDifference 
def findMinDiff(arr:list, n:int) -> int:
    arr,diff = sorted(arr),10**20
    for i in range(n-1):
        if arr[i+1] - arr[i] < diff: diff = arr[i+1] - arr[i]
    return diff

************************************************************************
20th Snippet -> Name findMinimumSum 
def findMin(arr:list) -> int:
    n,summation = len(arr),0
    for i in range(0, n): summation = summation + arr[i]
    arr.sort()
    minimum = arr[0]
    maximim = 0
    for i in range(n - 1, 0, -1):
        num = arr[i]
        total = num + minimum
        for j in range(2, num + 1):
            if(num % j == 0):
                d = j
                now = (num // d) + (minimum * d)
                reduce = total - now
                if(reduce > maximim): maximim = reduce
    return summation - maximim

************************************************************************
21th Snippet -> Name finishBefore 
finishBefore = lambda list_name, target : list(itertools.takewhile(lambda x : x != target, list_name))

************************************************************************
22th Snippet -> Name for++ 
for ${1:referenceValue} in ${2:arrayName}:
    ${3:Query}

************************************************************************
23th Snippet -> Name gcd_lcm 
def gcd(a:int,b:int) -> int: # Also known as Eucledian Algorithm
	if b == 0: return a
	else : return gcd(b, a % b)
lcm = lambda a,b : (a*b)/gcd(a,b)

************************************************************************
24th Snippet -> Name graph 

class Graph:
    def __init__(self, gdict = None):
        if gdict is None: gdict = {}
        self.gdict = gdict
    def getVertices(self): return list(self.gdict.keys())   # Get the keys of the dictionary
    def addVertex(self, vtx):         # Add a vertex
        if vtx not in self.gdict: self.gdict[vtx] = []
    def addEdge(self, vtx, edge):      # add an Edge
        v,e = vtx, edge
        if vtx in self.gdict: self.gdict[vtx].append(edge)
        else: self.gdict[vtx] = [edge]
    def getEdges(self):
        edgeNames = []
        for k,v in self.gdict.items():
            for every in v: edgeNames.append(every)
        return list(set(edgeNames)) 


    
    def dfs(self, visited, graph_elements, node):
        if node not in visited:
            store.append(node)
            for neighbour in graph_elements[node]:
                self.dfs(visited, graph_elements, neighbour)

************************************************************************
25th Snippet -> Name inf 
float('-inf')

************************************************************************
26th Snippet -> Name isConsecutive 
def isConsecutive(l:list) -> bool:
    flag = True
    temp = l[0]
    t = l[1:]
    for i in t:
        if i != temp + 1: flag = False; break
        elif i == temp + 1: temp = i
    return flag

************************************************************************
27th Snippet -> Name isCube 
def isCube(number : int) -> bool:
    cube_root = number**(1./3.)
    if round(cube_root) ** 3 == number: return True
    else: return False

************************************************************************
28th Snippet -> Name isDecreasing 
def isDecreasing(l:list) -> bool:
    start = l[0]
    culprit = None
    flag = False
    for idx,i in enumerate(l[1:]):
        if i <= start: start = i
        else: flag = True; culprit = idx; break
    temp = True if not flag else culprit
    return temp


************************************************************************
29th Snippet -> Name isfloat 
isfloat = lambda num : isinstance(num, float)

************************************************************************
30th Snippet -> Name isIncreasing 
def isIncreasing(l:list) -> bool:
    start = l[0]
    culprit = None
    flag = False
    for idx,i in enumerate(l[1:]):
        if i >= start: start = i
        else: flag = True; culprit = idx; break
    temp = True if not flag else culprit
    return temp

************************************************************************
31th Snippet -> Name isint 
isint = lambda num : isinstance(num, int)

************************************************************************
32th Snippet -> Name isPowerOfTwo 
isPowerOfTwo = lambda num : num and (not(num & (num - 1)))

************************************************************************
33th Snippet -> Name isPrime 
def isPrime( n : int ) -> bool:
    if n <= 1: return False
    if n % 2 == 0: return n == 2
    max_div = math.floor(math.sqrt(n))
    for i in range(3, 1 + max_div, 2):
        if n % i == 0: return False
    return True

************************************************************************
34th Snippet -> Name isSquare 
def isSquare(number : int) -> bool:
    root = math.sqrt(number)
    if int(root + 0.5) ** 2 == number: return True
    else: return False

************************************************************************
35th Snippet -> Name isSubsequence 
def isSubsequence(needle:str, haystack:str) -> bool:
    current_pos = 0
    for c in needle:
        current_pos = haystack.find(c, current_pos) + 1
        if current_pos == 0: return False
    return True

************************************************************************
36th Snippet -> Name jobSchedulingNoProfit 
def jobSchedulingNoProfit(arr:list)->list:
    n,result,maxHeap = len(arr),[],[]
    arr.sort(key=lambda x: x[1])
    for i in range(n - 1, -1, -1):
        if i == 0: slots_available = arr[i][1]
        else: slots_available = arr[i][1] - arr[i - 1][1]
        heapq.heappush(maxHeap, (-arr[i][2], arr[i][1], arr[i][0]))
        while slots_available and maxHeap:
            profit, deadline, job_id = heapq.heappop(maxHeap)
            slots_available -= 1
            result.append([job_id, deadline])
    result.sort(key=lambda x: x[1])
    return result

************************************************************************
37th Snippet -> Name jobSchedulingWithProfit 
    # print result's first element as the jobs name
def jobSchedulingWithProfit(startTime:list, endTime:list, profit:list)->int:
    jobs = sorted(zip(startTime, endTime, profit), key=lambda v: v[1])
    dp = [[0, 0]]
    for s, e, p in jobs:
        i = bisect.bisect(dp, [s + 1]) - 1
        if dp[i][1] + p > dp[-1][1]: dp.append([e, dp[i][1] + p])
    return dp[-1][1]

************************************************************************
38th Snippet -> Name L 
try: L(${1:logValue})
except: pass

************************************************************************
39th Snippet -> Name largestSubarray 
def largest_subarray(a,n):
    tmp_list = []
    max = 0
    for i in a:
        if i not in tmp_list:
            tmp_list.append(i)
        else:
            max = len(tmp_list) if len(tmp_list) > max else max
            tmp_list = [i]
    print (tmp_list)

************************************************************************
40th Snippet -> Name lcmOfArray 
def LCMofArray(a:list) -> int:
    lcm = a[0]
    for i in range(1,len(a)): lcm = lcm*a[i]//math.gcd(lcm, a[i])
    return lcm

************************************************************************
41th Snippet -> Name longestPalindrome 
def longestPalindrome(s:list) -> list:
    dp = [[False for i in range(len(s))] for i in range(len(s))]
    for i in range(len(s)): dp[i][i] = True
    max_length = 1
    start = 0
    for l in range(2,len(s)+1):
        for i in range(len(s)-l+1):
            end = i+l
            if l==2:
               if s[i] == s[end-1]:
                  dp[i][end-1]=True
                  max_length = l
                  start = i
            else:
               if s[i] == s[end-1] and dp[i+1][end-2]:
                  dp[i][end-1]=True
                  max_length = l
                  start = i
    return s[start:start+max_length]

************************************************************************
42th Snippet -> Name makeTwoBinaryEqual 
def makeTwoBinaryEqual(list1: list, list2: list) -> None:
    absolute,list1Length,list2Length = abs(len(list1) - len(list2)),len(list1),len(list2)
    if list1Length > list2Length :
        for i in range(absolute) : list2.insert(0,'0')
    elif list1Length < list2Length :
        for i in range(absolute) : list1.insert(0,'0')

************************************************************************
43th Snippet -> Name maxIncreasingSubarray 
def maxIncreasingSubArray(arr : list) -> int:
    c,temp = 1,[]
    if len(arr)==1: return 1
    else:
        start,idx = arr[0],1
        while idx < len(arr):
            if arr[idx] > start: start = arr[idx]; c+=1
            else: temp.append(c); start = arr[idx]; c = 1
            idx+=1
        temp.append(c)
        return max(temp)

************************************************************************
44th Snippet -> Name maxSubarraySum 
def maxSubarraySum(n:int, array:list) -> int:
    best = s = 0
    for k in range(n):
        s = max(array[k],s+array[k])
        if s < 0 and max(best,s)==0 and min(best,s)<0: best = s
        else : best = max(best,s)
    return best

************************************************************************
45th Snippet -> Name minDifferenceOfTwoArray 
def min_difference_two_subsets(index : int = 0, a : int = 0, b : int  = 0, weights : list) -> int:
    if index >= len(weights): return abs(a - b)
    return min(min_difference(index + 1, a + weights[index], b), min_difference(index + 1, a, b + weights[index])) : int

************************************************************************
46th Snippet -> Name minimumDifference 
def findMinDiff(arr, n):
    arr = sorted(arr)
    diff = 10**20
    for i in range(n-1):
        if arr[i+1] - arr[i] < diff: diff = arr[i+1] - arr[i]
    return diff

************************************************************************
47th Snippet -> Name minimumSum 
# Function to return the minimum sum
def findMin(arr):
    n = len(arr)
    sum = 0
    for i in range(0, n): sum = sum + arr[i]
    arr.sort()
    min = arr[0]
    max = 0
    for i in range(n - 1, 0, -1):
        num = arr[i]
        total = num + min
        for j in range(2, num + 1):
            if(num % j == 0):
                d = j
                now = (num // d) + (min * d)
                reduce = total - now
                if(reduce > max): max = reduce
    return sum - max

************************************************************************
48th Snippet -> Name n2a 
n2a = {v:chr(k) for k,v in zip(range(97,97+27),range(1,27))}

************************************************************************
49th Snippet -> Name nCr 
def ncr(n:int,r:int) -> int:
    if r > n: return(0)
    else: return(math.factorial(n) // (math.factorial(n - r) * math.factorial(r)))

************************************************************************
50th Snippet -> Name Node 
class Node:
    def __init__(self,data = None): self.data,self.next,self.prev=data,None,None

************************************************************************
51th Snippet -> Name noOfSubarraysOfSumK 
def no_of_subarrays_of_sum_k (nums: list, k: int) -> int:
    ans , prefsum, d = 0,  0, {0:1}
    for num in nums:
        prefsum += num
        if  prefsum-k  in  d: ans = ans + d[prefsum-k]
        d[prefsum] = d.get(prefsum, 0) + 1
    return ans

************************************************************************
52th Snippet -> Name nPr 
def npr(n:int,r:int) -> int:
    if r > n: return(0)
    else: return(math.factorial(n) // math.factorial(n - r))

************************************************************************
53th Snippet -> Name nsu 
ii  = lambda : int(input())                           
si  = lambda : input()                               
mi  = lambda : map(int,input().strip().split(" "))   
msi = lambda : map(str,input().strip().split(" "))   
li  = lambda : list(mi())                            
lsi = lambda : list(msi())                 

${1:main}

************************************************************************
54th Snippet -> Name nthNumber 
'''Kth number when stacked together'''
def kth_number( k : int ) -> str :
    length = first = 1
    while k > 9 * first * length:
        k -= 9 * first * length
        length += 1
        first *= 10
    q, r = divmod(k-1, length)
    return str(first + q)[r]

************************************************************************
55th Snippet -> Name numberLineJump 
def number_line_jump(first_begin:int, first_hop:int, second_begin:int, second_hop:int) -> str:
    if first_begin < second_begin and first_hop < second_hop: return 'NO'
    else:
        if first_hop!=second_hop and (second_begin-first_begin)%(second_hop-first_hop)==0: return 'YES' 
        else: return 'NO'

************************************************************************
56th Snippet -> Name optimizer 
def optimizer(f):
    memory = {}
    def wrapper(args):
        if args not in memory.keys(): memory[args] = f(args)
        return memory[args]
    return wrapper

************************************************************************
57th Snippet -> Name orderLowercase 
orderLowercase = lambda character : ord(character)-97

************************************************************************
58th Snippet -> Name orderUppercase 
orderUppercase = lambda character : ord(character)-65

************************************************************************
59th Snippet -> Name pascalsTriangle 
def pascals_triangle(n:int)-> list:
    triangle = []
    for i in range(n):
        sr = []
        for j in range(i+1): sr.append(math.factorial(i)//(math.factorial(j)*math.factorial(i-j)))
        triangle.append(sr)
    return triangle

************************************************************************
60th Snippet -> Name powerOfTwo 
def power_two(x:int) -> int: return (x and (not(x & (x - 1))))

************************************************************************
61th Snippet -> Name powerSet 
def powerset(some_list:list)->list:
    if len(some_list) == 0: return [[]]
    subsets = []
    first_element = some_list[0]
    remaining_list = some_list[1:]
    for partial_subset in powerset(remaining_list):
        subsets.append(partial_subset)
        subsets.append(partial_subset[:] + [first_element])
    return subsets

************************************************************************
62th Snippet -> Name prefixSum 
def prefixSum(arr:list) -> list:
    newArray,idx = [],0
    while idx < len(arr):
        if idx==0: newArray.append(arr[idx])
        else: ans = arr[idx] + newArray[-1]; newArray.append(ans)
        idx+=1
    return newArray

************************************************************************
63th Snippet -> Name primeFactors 
def prime_factors(n:int) -> list:
    q = []
    while n % 2 == 0: q.append(2); n = n // 2
    for i in range(3,int(n ** 0.5) + 1,2):
        while n % i == 0: q.append(i); n = n // i
    if n > 2: q.append(n)
    return list(sorted(q))

************************************************************************
64th Snippet -> Name print 
print(f"{${1:value}}",end="\n")

************************************************************************
65th Snippet -> Name project 
import pyperclip, time
import json,datetime
from datetime import date
from send2trash import send2trash
import os, webbrowser, pyautogui, shutil, colorama
from tkinter import *
from prettytable import PrettyTable
from tabulate import tabulate
from colorama import Fore, Back, Style
colorama.init(autoreset=True)
from ping3 import ping, verbose_ping # ping("address")
### from pythonping import ping # ping("address",verbose=True)

#os.system('mode con: cols=80 lines=50')
nl = lambda lines : print(lines*"\n", end="")

RED =  F"{Fore.RED}"
GREEN =  F"{Fore.GREEN}"
YELLOW = F"{Fore.YELLOW}"
BLUE = F"{Fore.BLUE}"
MAGENTA = F"{Fore.MAGENTA}"
CYAN = F"{Fore.CYAN}"
WHITE =  F"{Fore.WHITE}"

LRED =  F"{Fore.LIGHTRED_EX}"
LGREEN =  F"{Fore.LIGHTGREEN_EX}"
LYELLOW = F"{Fore.LIGHTYELLOW_EX}"
LBLUE = F"{Fore.LIGHTBLUE_EX}"
LMAGENTA = F"{Fore.LIGHTMAGENTA_EX}"
LCYAN = F"{Fore.LIGHTCYAN_EX}"
LWHITE = F"{Fore.LIGHTWHITE_EX}"

def main() -> None:
	${1:pass}
	
if __name__ == "__main__":	main()

************************************************************************
66th Snippet -> Name repeatedSubstringPattern 
def repeatedSubstringPattern(s: str) -> bool:
    for i in range(1,int(len(s)/2)+1):
        if set(s.split(s[0:i])) == {''}: return True 
    return False

************************************************************************
67th Snippet -> Name schedule 
def eraseOverlapIntervals(intervals):
    end, cnt = float('-inf'), 0
    for s, e in sorted(intervals, key=lambda x: x[1]):
        if s >= end: end = e
        else: cnt += 1
    return cnt

************************************************************************
68th Snippet -> Name sieveOfErathroses 
def seive(n : int) -> list:
    allprime,prime,p = [1],[True for i in range(n + 1)],2
    while (p * p <= n): 
        if (prime[p] == True): 
            for i in range(p ** 2,n + 1,p): prime[i] = False
        p = p + 1
    for p in range(2,n + 1): 
        if prime[p]: allprime.append(p)
    return allprime

************************************************************************
69th Snippet -> Name SinglyLinkedList 
class SinglyLinkedList:
    def __init__(self): self.head = None
    def listPrint(self):
        printval = self.head
        while printval is not None:print(f"{printval.data}",end="\n");printval = printval.next
    def insertAtBeginning(self, newData): NewNode=Node(newData);NewNode.next=self.head;self.head=NewNode
    def insertAtLast(self, newData):
        NewNode = Node(newData)
        if self.head is None: self.head=NewNode;return
        last = self.head
    def Inbetween(self,middle_node,newdata):
        if middle_node is None:print("The mentioned node is absent");return
        NewNode = Node(newdata)
        NewNode.nextval = middle_node.nextval
        middle_node.nextval = NewNode

************************************************************************
70th Snippet -> Name sortByDictionaryValues 
sortByValues = lambda dick : {k: v for k, v in sorted(dick.items(), key=lambda item: item[1])}

************************************************************************
71th Snippet -> Name sortByReversedValues 
sortByValuesReversed = lambda dick : {k: v for k, v in sorted(dick.items(), key=lambda item: item[1], reverse=True)}

************************************************************************
72th Snippet -> Name startFrom 
startFrom = lambda list_name, target : list(itertools.dropwhile(lambda x : x != target, list_name))

************************************************************************
73th Snippet -> Name stringPatternSearching 
def string_pattern_searching(haystack:str, needle:str) -> int:
    """Knuth-Morris-Prat Algorithm"""
    s : str = needle + "#" + haystack
    n = len(s)
    pi_s = [0] * n
    j : int = 0
    for i in range(1, n):
        while j > 0 and s[j] != s[i]: j = pi_s[j - 1]
        if s[i] == s[j]: j += 1
        pi_s[i] = j
    # for the array return pi_s
    ans = 0
    for l in pi_s:
        if l == len(needle): ans += 1
    return ans
    # for the no of matches return the ans

************************************************************************
74th Snippet -> Name subarraySumEqualToK 
def subarray_sum_equal_to_k ( a : list , K : int ) -> int :
    n = len(a)
    hash = defaultdict(lambda: 0)
    count = 0
    sum = 0
    for i in range(n):
        sum += a[i]
        if sum == K: count += 1
        if (sum - K) in hash: count += hash[sum - K]
        hash[sum] += 1
    return count

************************************************************************
75th Snippet -> Name templateBlank 
# BOOGEYMAN >>> Version 12.0
def BoogeyMan() -> None:
    '''
    ${1:Query}
    '''
    ${2:Query}
            
if __name__ == "__main__":
    import os, sys, math, itertools, bisect
    from collections import deque, defaultdict, OrderedDict, Counter
    from functools import cache, lru_cache # @lru_cache(maxsize=100)
    ii,si = lambda : int(input()), lambda : input()               
    mi, msi  = lambda : map(int,input().strip().split(" ")), lambda : map(str,input().strip().split(" ")) 
    li, lsi = lambda : list(mi()), lambda : list(msi())
    try:
        from baba_yaga import cmdIO, _generator_, logging, log as L
        class _BoogeyMan_:
            def __init__(self) -> None: self.launchers = [cmdIO(), BoogeyMan(), _generator_()]
            def init(self) -> None:
                for _ in self.launchers: yield _ ; assert not _ , "EOF" 
            def container(fun) :
                def wrapper(): print(f"AC",end="\n"); fun()
                return wrapper
        @_BoogeyMan_.container
        def launcher() : _BoogeyMan_().init()
        launcher()
    except (FileNotFoundError,ModuleNotFoundError): BoogeyMan()

************************************************************************
76th Snippet -> Name ternary 
print("YES") if ${2:condition} else print("NO")

************************************************************************
77th Snippet -> Name timer 
import time
start = time.time()
${1:Code}
end = time.time() - start()
print(f"{end-start}",end="\n")

************************************************************************
78th Snippet -> Name toBinary 
toBinary = lambda num : int(str(bin(num))[2:])

************************************************************************
79th Snippet -> Name towerOfHanoi 
def tower_of_hanoi(n:int, from_rod:int, to_rod:int, aux_rod:int):
    if n==1:
        print(f"{from_rod} {to_rod}",end="\n")
        return
    tower_of_hanoi(n-1, from_rod, aux_rod, to_rod)
    print(f"{from_rod} {to_rod}",end="\n")
    tower_of_hanoi(n-1, aux_rod, to_rod, from_rod)
    #print(f"{(1<<n)-1}",end="\n")
    #tower_of_hanoi(n,1,3,2)

************************************************************************
80th Snippet -> Name trailingZeroes 
def trailing_zeroes(n:int) -> int:
    # divide the number with the powers of 5
    i = 5
    no_of_zeroes = 0
    while n/i>=1:
        no_of_zeroes += n/i
        i*=5
    return int(no_of_zeroes)

************************************************************************
81th Snippet -> Name treeTraversal 
# Works for binary tree also
class Node:
    def __init__(self, item):
        self.left = None
        self.right = None
        self.val = item

inorderStore, postorderStore, preorderStore = [],[],[]

def inorder(root):
    # In - Order >>> Left - Process - Right
    if root: inorder(root.left); inorderStore.append(root.val); inorder(root.right)
    return inorderStore

def postorder(root):
    # Post - Order >>> Left - Right - Process
    if root: postorder(root.left); postorder(root.right); postorderStore.append(root.val)
    return postorderStore
def preorder(root):
    # Pre - Order >>> Process - Left - Right
    if root: preorderStore.append(root.val); preorder(root.left); preorder(root.right)
    return preorderStore
def flushNodeStores() -> None:
    inorderStore.clear()
    preorderStore.clear()
    postorderStore.clear()

************************************************************************
82th Snippet -> Name trueFalse 
print('FTARLUSEE'[${1:condition}::2])

************************************************************************
83th Snippet -> Name twoKnightsAttackEachOther 
for i in range ( 1 , k+1 ) :
    ans = 0
    ans += 4 * (i ** 2 - 3)
    ans += 8 * (i ** 2 - 4)
    ans += 4 * (i - 3) * (i ** 2 - 5)
    ans += 4 * (i - 4) * (i ** 2 - 7)
    ans += ((i - 4) ** 2) * (i ** 2 - 9) # cell greater than 9x9
    print(ans // 2)

************************************************************************
84th Snippet -> Name twoSetsEqualSum 
n = int(input())
s = (n * (n + 1)) // 2
if s % 2 == 0:
    print("YES")
    s //= 2
    arr1 = set()
    while s >= n:
        arr1.add(n)
        s -= n
        n -= 1

    if s > 0: arr1.add(s)

    print(len(arr1))
    print(*arr1)

    arr2 = set(range(1, n + 1)) - arr1
    print(len(arr2))
    print(*arr2)
else: print("NO")

************************************************************************
85th Snippet -> Name vowels 
vowels = ['a','e','i','o','u']

************************************************************************
86th Snippet -> Name whileLoop 
idx = 0
while ${1:condition}:
	idx+=1

************************************************************************
87th Snippet -> Name yesNo 
print('YNEOS'[${1:condition}::2])
